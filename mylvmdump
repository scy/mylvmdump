#!/bin/sh

# Read configuration values.
source mylvmdump.conf

# Do not log what we do.
# It may be confusing when later using mysql interactively.
export MYSQL_HISTFILE=/dev/null

# List of options for parseable mysql results.
PARSEABLE='--skip-column-names'

# Initial set of mysqldump options to use.
DUMPOPTS='--skip-opt --add-drop-table --add-locks --create-options --disable-keys --extended-insert --quick --set-charset'

# Exit with an error message.
die() {
	echo "$1"
	exit 1
}

# Run a MySQL command-line tool, supplying configuration data on FD 4.
runwithcfg() {
	# --defaults-extra-file needs to be the first option,
	# therefore take apart command name and parameters.
	cmd="$1"
	shift
	"$cmd" --defaults-extra-file=/dev/fd/4 "$@" 4<<-EOF
		[client]
		user=$user
		password=$pass
		host=$host
		EOF
}

# Interpret boolean configuration variables.
bool() {
	[ -z "${!1}" ] && return 1
	case "${!1}" in
		0|-|off|ofF|oFf|oFF|Off|OfF|OFf|OFF|n*|N*|f*|F*)
			return 1
			;;
	esac
	return 0
}

# Run a hook.
runhook() {
	declare -F | grep -q " $1\$" || return 1
	hookname="$1"
	shift
	$hookname "$@"
}

# Check the free space.
checkfreespace() {
	[ -z "$keepfree" ] && return 0
	dir="$(dirname "$1")"
	suf="$(echo "$keepfree" | tr -cd 'A-Z')"
	num="$(echo "$keepfree" | tr -cd '0-9')"
	free="$(df -B "1$suf" "$dir" | tail -n +2 | awk '{ print $4 }')"
	[ "$free" -ge "$num" ] && return 0
	echo "not enough space: only $free$suf left, requiring $num$suf"
	return 1
}


# Read command-line options.
purgeonly=n
while getopts p o; do
	case "$o" in
		p)
			purgeonly=y
			;;
		*)
			exit 1
			;;
	esac
done

# Check for a useful keepfree value.
keepfree="$(echo "$keepfree" | tr a-z A-Z | tr -cd 0-9KMGTPEZYB)"
if [ "$keepfree" != "$(echo "$keepfree" | grep -E '^[1-9][0-9]*[KMGTPEZY]B?')" ]; then
	die "Strange keepfree value '$keepfree'."
fi

# Set the precompress command.
compressdefaults=y
case "$compress" in
	gzip)
		compresstype=gz
		;;
	bzip2|pbzip2)
		compresstype=bz2
		;;
	*)
		compresscmd='cat'
		compresstype=''
		compresssuffix=''
		compressdefaults=n
		;;
esac
if [ "$compressdefaults" = 'y' ]; then
	compresssuffix=".$compresstype"
	compresscmd="$compress"
fi



if ! bool purgeonly; then
	# Retrieve the list of databases.
	databases="$(runwithcfg mysql $PARSEABLE <<-"EOF"
		SHOW DATABASES;
		EOF
	)"
	# Convert into a space-delimited list.
	databases="$(echo "$databases" | tr '\n' ' ' | sed -r -e 's/(^ +| +$)//g' -e 's/ {2,}/ /g')"
	
	# List available databases, comma-delimited.
	echo -n "Available databases: "
	echo "$databases" | sed -e 's/ /, /g'
	
	# Dump each database.
	for database in $databases; do
		dumpname="$(eval "echo $namepattern")"
		echo -n "Dumping $database to $dumpname... "
		started="$(date +%s)"
		tempname="$(eval "echo $temppattern")"
		if [ -z "$tempname" ]; then
			tempname="$dumpname"
			movetemp=n
		else
			movetemp=y
		fi
		bool tempexists && [ ! -e "$tempname" ] && die "temporary file $tempname does not exist"
		checkfreespace "$tempname" && \
		runwithcfg mysqldump $DUMPOPTS "$database" |
			"$compresscmd" \
			> "$tempname"
		r="$?"
		if [ "$r" -eq 0 ]; then
			[ "$movetemp" = 'y' ] && mv "$tempname" "$dumpname"
			runhook after_dump
			stopped="$(date +%s)"
			seconds="$(expr "$stopped" - "$started")"
			size="$(stat -c %s "$dumpname")"
			megs="$(expr "$size" / 1024 / 1024)"
			echo "ok, $seconds seconds, $megs MiB."
		else
			[ "$movetemp" = 'y' ] && rm -f "$tempname"
		fi
	done
fi

# Purge older dumps, if configured to.
purge="$(echo "$purge" | grep -Ev '^[[:space:]]*$')"
echo "$purge" | while read line; do
	pattern="$(echo "$line" | cut -d '|' -f 1)"
	date="$(echo "$line" | cut -d '|' -f 2)"
	echo "Purging all '$pattern' older than $date... "
	find -name "$pattern" -and -not -newermt "$date" -print -exec rm '{}' \; | sed -e 's/^/\t/'
done

# This will be used later on.
# lvs --noheadings --nosuffix --separator : --units b --options lv_name,lv_size | sed -r -e 's/^ +//'
