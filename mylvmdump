#!/bin/sh

# Read configuration values.
source mylvmdump.conf

# Do not log what we do.
# It may be confusing when later using mysql interactively.
export MYSQL_HISTFILE=/dev/null

# List of options for parseable mysql results.
PARSEABLE='--skip-column-names'

# Initial set of mysqldump options to use.
DUMPOPTS='--skip-opt --add-drop-table --add-locks --create-options --disable-keys --extended-insert --quick --set-charset'

# Exit with an error message.
die() {
	echo "$1"
	exit 1
}

# Run a MySQL command-line tool, supplying configuration data on FD 4.
runwithcfg() {
	# --defaults-extra-file needs to be the first option,
	# therefore take apart command name and parameters.
	cmd="$1"
	shift
	"$cmd" --defaults-extra-file=/dev/fd/4 "$@" 4<<-EOF
		[client]
		user=$user
		password=$pass
		host=$host
		EOF
}

# Interpret boolean configuration variables.
bool() {
	[ -z "${!1}" ] && return 1
	case "${!1}" in
		0|-|off|ofF|oFf|oFF|Off|OfF|OFf|OFF|n*|N*|f*|F*)
			return 1
			;;
	esac
	return 0
}

# Run a hook.
runhook() {
	declare -F | grep -q " $1\$" || return 1
	hookname="$1"
	shift
	$hookname "$@"
}

# Check the free space.
checkfreespace() {
	[ -z "$keepfree" ] && return 0
	dir="$(dirname "$1")"
	suf="$(echo "$keepfree" | tr -cd 'A-Z')"
	num="$(echo "$keepfree" | tr -cd '0-9')"
	free="$(df -B "1$suf" "$dir" | tail -n +2 | awk '{ print $4 }')"
	[ "$free" -ge "$num" ] && return 0
	echo "not enough space: only $free$suf left, requiring $num$suf"
	return 1
}

# Check whether a database is filtered or not.
dbfiltered() {
	[ "$(getflag "$dbfilterdefault" '+-' "$1" "$dbfilter")" = '-' ]
}

# Get the filter flag for database/table $3 by parsing the list in $4. Default
# flag is $1, allowed characters are $2.
getflag() {
	result="$1"
	echo "$4" | while read line; do
		flag=''
		mode='.'
		origline="$line"
		while [ -z "$flag" ]; do
			char="$(echo "$line" | cut -b 1  2>/dev/null)"
			line="$(echo "$line" | cut -b 2- 2>/dev/null)"
			if   [ -n "$(echo "$char" | tr -cd '.^')" ]; then
				mode="$char"
			elif [ -n "$(echo "$char" | tr -cd "$2")" ]; then
				flag="$char"
			else
				# Invalid line (content before flag?)
				continue 2
			fi
		done
		if [ "$mode" = '.' ]; then
			[ "$3" = "$line" ] && result="$flag"
		elif [ "$mode" = '^' ]; then
			echo "$3" | grep -E -q "$line" 2>/dev/null && result="$flag"
		fi
		echo -n "$result"
	done | tail -c 1
}

# Get a newline-separated list of database names.
getdatabases() {
	runwithcfg mysql $PARSEABLE <<-"EOF"
		SHOW DATABASES;
		EOF
}

# Get a newline-separated list of table names in database $1.
gettables() {
	runwithcfg mysql $PARSEABLE "$1" <<-"EOF"
		SHOW TABLES;
		EOF
}

# Get the inclusion flag for table $2 in database $1.
gettableflag() {
	# Set to default.
	flag="$tablefilterdefault"
	# Create a list of variable names to consider.
	vars='tablefilter'
	[ "$1" = "$(echo "$1" | grep -E "^[a-zA-Z_][0-9a-zA-Z_]*$")" ] && vars="$vars tablefilter__$1"
	for hash in md5 sha1 sha512; do # Update docs when changing algorithm list.
		which "${hash}sum" >/dev/null 2>&1 && vars="$vars tablefilter_${hash}_$(echo -n "$1" | ${hash}sum | cut -d ' ' -f 1)"
	done
	# Get the flag for each of the variables.
	for var in $vars; do
		flag="$(getflag "$flag" '+-~' "$2" "${!var}")"
		echo "\$flag after considering \$$var: $flag"
	done
	echo "$flag"
}


# Read command-line options.
purgeonly=n
while getopts p o; do
	case "$o" in
		p)
			purgeonly=y
			;;
		*)
			exit 1
			;;
	esac
done

# Check for a useful keepfree value.
keepfree="$(echo "$keepfree" | tr a-z A-Z | tr -cd 0-9KMGTPEZYB)"
if [ "$keepfree" != "$(echo "$keepfree" | grep -E '^[1-9][0-9]*[KMGTPEZY]B?')" ]; then
	die "Strange keepfree value '$keepfree'."
fi

# Set the precompress command.
compressdefaults=y
case "$compress" in
	gzip)
		compresstype=gz
		;;
	bzip2|pbzip2)
		compresstype=bz2
		;;
	*)
		compresscmd='cat'
		compresstype=''
		compresssuffix=''
		compressdefaults=n
		;;
esac
if [ "$compressdefaults" = 'y' ]; then
	compresssuffix=".$compresstype"
	compresscmd="$compress"
fi



if ! bool purgeonly; then
	# Retrieve the list of databases.
	databases="$(getdatabases)"
	
	# List available databases, comma-delimited.
	echo -n "Available databases: "
	echo "$databases" | sed -r -e 's/$/, /' | tr -d '\n' | head -c -2
	echo
	
	# Dump each database.
	echo "$databases" | while read database; do
		if dbfiltered "$database"; then
			echo "Skipping $database (filtered)."
			continue
		fi
		dumpname="$(eval "echo $namepattern")"
		echo -n "Dumping $database to $dumpname... "
		tables="$(gettables "$database")"
		started="$(date +%s)"
		tempname="$(eval "echo $temppattern")"
		if [ -z "$tempname" ]; then
			tempname="$dumpname"
			movetemp=n
		else
			movetemp=y
		fi
		bool tempexists && [ ! -e "$tempname" ] && die "temporary file $tempname does not exist"
		checkfreespace "$tempname" && \
		runwithcfg mysqldump $DUMPOPTS "$database" |
			"$compresscmd" \
			> "$tempname"
		r="$?"
		if [ "$r" -eq 0 ]; then
			[ "$movetemp" = 'y' ] && mv "$tempname" "$dumpname"
			runhook after_dump
			stopped="$(date +%s)"
			seconds="$(expr "$stopped" - "$started")"
			size="$(stat -c %s "$dumpname")"
			megs="$(expr "$size" / 1024 / 1024)"
			echo "ok, $seconds seconds, $megs MiB."
		else
			[ "$movetemp" = 'y' ] && rm -f "$tempname"
		fi
	done
fi

# Purge older dumps, if configured to.
purge="$(echo "$purge" | grep -Ev '^[[:space:]]*$')"
echo "$purge" | while read line; do
	pattern="$(echo "$line" | cut -d '|' -f 1)"
	date="$(echo "$line" | cut -d '|' -f 2)"
	echo "Purging all '$pattern' older than $date... "
	find -name "$pattern" -and -not -newermt "$date" -print -exec rm '{}' \; | sed -e 's/^/\t/'
done

# This will be used later on.
# lvs --noheadings --nosuffix --separator : --units b --options lv_name,lv_size | sed -r -e 's/^ +//'
