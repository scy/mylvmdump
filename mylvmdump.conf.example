# This file is sourced as a shell script.
# All shell syntax rules apply -- and all magical things you can do.

# Boolean variables may take these values (case insensitive):
# '' (empty string), '0', '-', 'off', anything starting with n or f (like 'no'
# or 'false') is interpreted as 'no', anything else as 'yes'.


# User name to access the MySQL database.
user='root'

# Password to access the MySQL database.
# Will be supplied securely (via fd) to mysqldump.
pass='5o0p3r$e(uRe'

# Database host to contact.
host='dbserver'


# Compression tool to use. Current choices are:
# gzip   (any non-ancient version should work)
# bzip2  (same here)
# pbzip2 (you need >=1.0.3)
# cat    (will not compress at all; the default)
compress='gzip'


# File name pattern of the generated files.
# You may insert any shell construct here, although variables should be
# sufficient fo most users. Some variables you might want to use are:
# $database        name of the database, e.g. 'mediawiki'
# $compresstype    'gz', 'bz2' or the empty string '' if not compressing
# $compresssuffix  $compresstype, but prefixed by a dot if non-empty ('.gz')
# $(date "+...")   see date(1) for the available options
# This string will be evaluated using "eval", so please put it in single quotes,
# use double quotes inside it and don't add security holes. If a variable name
# is followed by a character that's valid in variable names, use the syntax
# '${variable}moretext' as shown in the example. If unsure, always use {}.
namepattern='$(date "+%Y-%m-%d_%H-%M-%S")_${database}.sql${compresssuffix}'


# Temporary file name while dumping. Set to the empty string to dump directly
# into the final file name. You may use the same variables and constructs as in
# namepattern. Additionally, you can access the expanded namepattern itself as
# ${dumpname}. Use of mktemp is suggested. Please see the tempexists setting.
temppattern='$(mktemp -q --tmpdir=. "$dumpname.tmp.XXXXXXXXXX")'

# Whether the file name in temppattern should be checked fo existence. If this
# is set, mylvmdump will exit with an error if the temp file does not already
# exist. This is useful when using mktemp: If mktemp cannot create the file,
# mylvmdump will (and should) stop.
tempexists='yes'


# Hooks are a powerful way to extend mylvmdump's behavior. They are called
# before or after certain actions and allow you to run custom code.

# after_dump(): Called after a successful dump, i.e. after moving the temp file
# (if any) to its final file name. Useful variables are $database and $dumpname.
# This example will hard-link the file to a "daily" snapshot if the time is
# between 4am and 8am. (Think of 4-hourly snapshots, one of which is selected as
# the "daily" one.)
after_dump() {
	hour="$(date +%-H)"
	if [ "$hour" -ge 4 -a "$hour" -lt 8 ]; then
		dailyname="$(echo "$dumpname" | sed -r -e 's/^([0-9-]+_)[0-9-]+_(.+)$/\1\2/')"
		ln "$dumpname" "$dailyname"
	fi
}
