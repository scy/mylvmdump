#!/bin/sh

COMMANDS='
help:Show a list of possible commands.
?:=help
vgfree:Return number of free bytes for given VG.
quit:Exit mylvmtool.
exit:=quit
'

# Show usage information and exit.
usage() {
	cat <<-EOF
		usage: mylvmtool -d <datadir>

		  mylvmtool is a helper application for mylvmdump and is not intended to
		  be called by the user directly. It needs to be run as root.

		  Once started, it reads simple commands from standard input to query and
		  manipulate the LVM. Use the "?" command to retrieve a command list.

		-d <datadir>  The base directory for MySQL databases.
	EOF
	exit 0
}

# Find the root of the filesystem containing $1.
findfsroot() {
	# Canonicalize $dir to be a directory, regardless of whether $1 is a file or
	# a directory.
	if [ ! -d "$1" ]; then
		dir="$(dirname "$1")"
	else
		dir="$1"
	fi
	while [ "$(stat -c %d "$dir")" -eq "$(stat -c %d "$dir/..")" -o "$dir" == '/' ]; do
		echo "$dir" >&2
		dir="$(readlink -m "$dir/..")"
	done
	echo "$dir"
}

# Check whether $1 is a valid command and run it.
dispatch() {
	# Store and shift.
	cmd="$1"; shift
	# Retrieve the matching line from $COMMANDS, if any.
	line="$(echo "$COMMANDS" | grep "^$cmd:")"
	# If such a line exists, run the command.
	if [ -n "$line" ]; then
		# But first, resolve a possible alias.
		al="$(echo "$line" | sed -n -e 's/^.\+:=\(.\+\)$/\1/p')"
		[ -n "$al" ] && cmd="$al"
		# Run the command.
		"$cmd" "$@"
		# Store the return value.
		r="$?"
	else
		echo 'Command not found. Use "help" for more information.' >&2
		return 0
	fi
	return "$r"
}

# Return the number of bytes free in volume group $1.
vgfree() {
	vgs --noheadings --nosuffix --separator : --units b --options vg_free "$1"
}

# Show help, directly created from $COMMANDS.
help() {
	echo "$COMMANDS" | while read line; do
		# If the line is empty, read the next one.
		[ -z "$line" ] && continue
		# Everything up to the colon is the command.
		cmd="$(echo "$line" | cut -d : -f 1)"
		# Everything after the description.
		dsc="$(echo "$line" | cut -d : -f 2- | sed -e 's/^=/  alias for /')"
		# Output the line.
		printf '%18s  %s\n' "$cmd" "$dsc"
	done
}

# Quit mylvmtool.
quit() {
	echo 'Bye.'
	return 1
}



# If no options are supplied, quit with usage message.
[ -z "$*" ] && usage

# Parse options.
while getopts d:h o; do
	case "$o" in
		d)
			# Set datadir to the checked option value.
			datadir="$(readlink -e "$OPTARG")"
			if [ -z "$datadir" ]; then
				echo 'cannot canonicalize datadir' >&2
				exit 1
			fi
			;;
		*)
			# On all other (including not understood) options, quit with usage.
			usage
			;;
	esac
done

# Main parser loop.
eof=0
while true; do
	# Read a line.
	read -p 'mylvmtool> ' line
	# Check the return status.
	eof="$?"
	[ "$eof" -eq 0 ] || break
	# Replace tabs with spaces and remove multiple spaces and spaces at
	# beginning and end.
	line="$(echo "$line" | tr '\t' ' ' | sed -e 's/^ \+//' -e 's/ \+$//' -e 's/ \+/ /g')"
	# cmd is the first word, all special characters removed.
	cmd="$(echo "$line" | tr -cd 'a-zA-Z0-9_? -' | cut -d ' ' -f 1)"
	# params is the rest.
	params="$(echo "$line" | cut -d ' ' -f 2-)"
	# Dispatch the command
	dispatch "$cmd" "$params" || break
done

# If EOF was given on a terminal, send a newline for more beauty.
[ "$eof" -ne 0 ] && tty >/dev/null && echo
# Exit.
exit 0
